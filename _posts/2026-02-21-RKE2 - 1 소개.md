---
layout: post
tags:
  - k8s
  - kubernetes
  - RKE2
title: "[K8S Deploy Study by Gasida] - RKE2 - 1 소개"
---
# RKE2 개요 및 아키텍처 

## RKE2 란 무엇인가?

KE2 (Rancher Kubernetes Engine 2) 는 SUSE (이전 Rancher Labs) 가 제공하는 **엔터프라이즈급 보안 중심 Kubernetes 배포판**이다. 공식 명칭은 **RKE2: The Next-Generation Kubernetes Distribution**이며 아래와 같은 환경에 적합하다.

- 보안 요구사항이 높은 환경 (CIS, FIPS)
- 공공기관 / 금융권
- Air-gapped(폐쇄망)
- Production-grade 온프레미스 / 클라우드

## RKE2의 핵심 특징

### 1. Hardened kubernetes

RKE2는 단순한 Kubernetes 배포판이 아니라 보안이 강화된(Hardened) Kubernetes이다.

- 기본적으로 CIS Kubernetes Benchmark 기준에 맞춰 설정
- SELinux 지원 : SELinux는 Linux 커널 레벨 Mandatory Access Control(MAC) 보안 시스템
- FIPS 모드 지원 : NIST가 제정한 보안 표준이 FIPS (Federal Information Processing Standards)이며 Kubernetes 구성 요소가 미국 정부 암호화 표준인 **FIPS 140-2 / 140-3** 규격을 만족하는 암호 모듈만 사용하도록 동작하는 모드를 의미한다.

### 2. 경량 + 단일 바이너리

RKE2는 복잡한 구성요소를 여러 패키지로 나누지 않는다. 아래 두 개의 바이너리만으로 클러스터를 구성한다.

- `rke2-server`
- `rke2-agent`

systemd 기반으로 단순한 설치구조를 가진다. 또한 설치 후 동작 방식은 단순하다. static pod 형태로 실행하여 systemd가 전체 라이프 싸이클을 관리한다.

RKE2는 내부적으로 
- `kube-apiserver`
- `scheduler`
- `controller-manager`
- `etcd`
를 static pod로 자동 배치한다. 따라서 운영자는 kubelet 설정을 직접 건드릴 필요가 거의 없다. 

### 3. Embedded Components

- etcd 내장 (외부 etcd 불필요)    
    - 별도 etcd 클러스터 구성 불필요하고 HA 시 자동 etcd cluster 형성하여 운영복잡도가 감소한다. kubespray와 비교하면 etcd 관리부담이 크게 줄어든다. 
- containerd가 기본 런타임이다.  
    - Docker Shim이 제거된 이후 구조에 최적화되어 있다.
- CoreDNS, metrics-server 자동 배포


### 4. Cloud Provider 독립적
- Bare-metal
- VMware    
- AWS / GCP / Azure
- Edge 환경
    - K3s보다 무겁지만 완전한 Kubernetes API 및 보안 강화, 경량화된 배포 방식으로 Edge + 보안 환경에 적합하다.



## RKE2 아키텍처 및 구성 요소

### 아키텍처

![](https://raw.githubusercontent.com/hyeonjae1122/hyeonjae1122.github.io/main/assets/20260221T050258861Z.png)


일단 시작되면 RKE2는 각 노드의 역할에 맞는 에이전트를 부트스트랩하고 관리하는 동시에 네트워크에서 필요한 콘텐츠를 가져올 수 있다.


### 구성요소

RKE2를 설치하면 다음과 같은 컴포넌트들이 한 번에 세팅된다. 
- Helm controller 
    - `/var/lib/rancher/rke2/server/manifests`
        - `rke2-canal-config.yaml`
        - `rke2-canal.yaml`
        - `rke2-coredns-config.yaml`
        - `rke2-coredns.yaml`
        - `rke2-metrics-server.yaml `
        - `rke2-runtimeclasses.yaml`
- runtime
    - containerd
    - runc
- CNI
    - `canal`: Calico & Falnnel, Cilium, Calico or Flannel

## 실행 단계

### 1) 부트스트랩 

RKE2는 실행되자마자 자기 몸체(런타임 이미지)에서 운영에 필요한 바이너리 파일과 차트를 꺼내서 특정 폴더에 깔끔하게 정리한다.

- 바이너리 추출
    - `kubectl`, `kubelet`, `containerd`, `socat` 등을 특정 데이터 폴더(`/var/lib/rancher/rke2/data/.../bin`)에 저장한다.
- 매니페스트 추출: 클러스터 구성에 필요한 Helm 차트들을 `/server/manifests` 디렉토리로 옮긴다.

### 2) 서버 초기화
서버 프로세스가 시작되면 핵심 컴포넌트들을 정적 파드(Static Pod) 형태로 띄울 준비를 한다.
- 의존성 관리: RKE2는 고루틴(Goroutine)을 이용해 앞 단계가 완료될 때까지 기다린다.
    - `etcd`는 `kubelet`이 준비될 때까지 대기.
    - `API Server`는 `etcd`가 준비될 때까지 대기.
    - `Controller Manager`와 `Scheduler`는 `API Server`가 준비될 때까지 대기.

- 정적 포드 생성: 준비가 되면 `/pod-manifests/` 폴더에 YAML 파일을 써서 `kubelet`이 이를 자동으로 실행하게 만듭니다.

이 모든 과정은 서로가 준비되었는지 확인하며 고루틴(Goroutine)에 의해 유기적으로 진행된다. 
### 3) 에이전트 및 앱 배포

서버 프로세스 안에는 에이전트 기능도 포함되어 있어, 실제 컨테이너를 돌릴 준비를 한다.
- 컨테이너 런타임: `containerd` 프로세스를 실행하고 감시합니다. 만약 `containerd`가 죽으면 RKE2 프로세스도 종료된다.
- 노드 에이전트: `kubelet`을 실행한다. `kubelet`이 뜨면 위에서 만든 정적 포드(etcd, API서버 등)들이 실제 컨테이너로 실행된다

### 4) **필수 앱 배포 (Helm Controller)**

클러스터의 뼈대(API 서버 등)가 완성되면, 내장된 **Helm Controller**가 동작한다.

- `/server/manifests`에 있는 차트들을 읽어서 네트워크(Canal/Cilium), DNS, Ingress 등을 클러스터에 자동으로 설치한다.

systemd 설정

### rke2-server 프로세스

RKE2 서비스 설정(`rke2-server.service`)에는아래와 같은 특징이 존재한다.

- `KillMode=process`: RKE2 메인 프로세스를 죽여도 내가 띄운 컨테이너들은 함부로 죽이지 말라는 설정입니다. 덕분에 업데이트 시 서비스 충격을 최소화한다.
    
- Delegate=yes: 리소스 관리(cgroup) 권한을 시스템(systemd)이 아닌 RKE2가 직접 관리하여 쿠버네티스 환경에 최적화된 제어를 수행한다.

```bash
cat /usr/lib/systemd/system/rke2-server.service
[Unit]
Description=Rancher Kubernetes Engine v2 (server)
Documentation=https://github.com/rancher/rke2#readme
Wants=network-online.target
After=network-online.target
Conflicts=rke2-agent.service

[Install]
WantedBy=multi-user.target

[Service]
Type=notify
EnvironmentFile=-/etc/default/%N
EnvironmentFile=-/etc/sysconfig/%N
EnvironmentFile=-/usr/lib/systemd/system/%N.env
KillMode=process   # "나만 죽이고, 내가 띄운 애들까지는 systemd가 건드리지 마" - RKE2, containerd 같은 애들은 내부적으로 여러 자식 프로세스 shim, runc, container 프로세스를 관리함. 물론 완전 무중단은 아니지만, 충격 최소화
Delegate=yes       # "cgroup(리소스 제어)는 내가 직접 관리할게" - cgroup(리눅스 리소스 그룹) 관리를 systemd가 아니라 자기 자신이 직접 하도록 위임(delegate) 하겠다는 의미.
LimitNOFILE=1048576
LimitNPROC=infinity
LimitCORE=infinity
TasksMax=infinity
TimeoutStartSec=0
Restart=always
RestartSec=5s
ExecStartPre=-/sbin/modprobe br_netfilter
ExecStartPre=-/sbin/modprobe overlay
ExecStart=/usr/bin/rke2 server
ExecStopPost=-/bin/sh -c "systemd-cgls /system.slice/%n | grep -Eo '[0-9]+ (containerd|kubelet)' | awk '{print $1}' | xargs -r kill"
```